/**

Generated by the following Solidity interface...
```solidity
interface OperatorStateRetriever {
    struct CheckSignaturesIndices {
        uint32[] nonSignerQuorumBitmapIndices;
        uint32[] quorumApkIndices;
        uint32[] totalStakeIndices;
        uint32[][] nonSignerStakeIndices;
    }
    struct Operator {
        address operator;
        bytes32 operatorId;
        uint96 stake;
    }

    function getCheckSignaturesIndices(address registryCoordinator, uint32 referenceBlockNumber, bytes memory quorumNumbers, bytes32[] memory nonSignerOperatorIds) external view returns (CheckSignaturesIndices memory);
    function getOperatorState(address registryCoordinator, bytes memory quorumNumbers, uint32 blockNumber) external view returns (Operator[][] memory);
    function getOperatorState(address registryCoordinator, bytes32 operatorId, uint32 blockNumber) external view returns (uint256, Operator[][] memory);
    function getQuorumBitmapsAtBlockNumber(address registryCoordinator, bytes32[] memory operatorIds, uint32 blockNumber) external view returns (uint256[] memory);
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "function",
    "name": "getCheckSignaturesIndices",
    "inputs": [
      {
        "name": "registryCoordinator",
        "type": "address",
        "internalType": "contract IRegistryCoordinator"
      },
      {
        "name": "referenceBlockNumber",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "quorumNumbers",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "nonSignerOperatorIds",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct OperatorStateRetriever.CheckSignaturesIndices",
        "components": [
          {
            "name": "nonSignerQuorumBitmapIndices",
            "type": "uint32[]",
            "internalType": "uint32[]"
          },
          {
            "name": "quorumApkIndices",
            "type": "uint32[]",
            "internalType": "uint32[]"
          },
          {
            "name": "totalStakeIndices",
            "type": "uint32[]",
            "internalType": "uint32[]"
          },
          {
            "name": "nonSignerStakeIndices",
            "type": "uint32[][]",
            "internalType": "uint32[][]"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorState",
    "inputs": [
      {
        "name": "registryCoordinator",
        "type": "address",
        "internalType": "contract IRegistryCoordinator"
      },
      {
        "name": "quorumNumbers",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "blockNumber",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple[][]",
        "internalType": "struct OperatorStateRetriever.Operator[][]",
        "components": [
          {
            "name": "operator",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "operatorId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "stake",
            "type": "uint96",
            "internalType": "uint96"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorState",
    "inputs": [
      {
        "name": "registryCoordinator",
        "type": "address",
        "internalType": "contract IRegistryCoordinator"
      },
      {
        "name": "operatorId",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "blockNumber",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "",
        "type": "tuple[][]",
        "internalType": "struct OperatorStateRetriever.Operator[][]",
        "components": [
          {
            "name": "operator",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "operatorId",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "stake",
            "type": "uint96",
            "internalType": "uint96"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getQuorumBitmapsAtBlockNumber",
    "inputs": [
      {
        "name": "registryCoordinator",
        "type": "address",
        "internalType": "contract IRegistryCoordinator"
      },
      {
        "name": "operatorIds",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      },
      {
        "name": "blockNumber",
        "type": "uint32",
        "internalType": "uint32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style
)]
pub mod OperatorStateRetriever {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x6080604052348015600e575f5ffd5b506119378061001c5f395ff3fe608060405234801561000f575f5ffd5b506004361061004a575f3560e01c80633563b0d11461004e5780634f739f74146100775780635c15566214610097578063cefdc1d4146100b7575b5f5ffd5b61006161005c3660046110ea565b6100d8565b60405161006e919061124b565b60405180910390f35b61008a6100853660046112ab565b610540565b60405161006e91906113ab565b6100aa6100a5366004611483565b610c3a565b60405161006e9190611532565b6100ca6100c5366004611574565b610def565b60405161006e9291906115b3565b60605f846001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa158015610117573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013b91906115d3565b90505f856001600160a01b0316639e9923c26040518163ffffffff1660e01b8152600401602060405180830381865afa15801561017a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061019e91906115d3565b90505f866001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101dd573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061020191906115d3565b90505f86516001600160401b0381111561021d5761021d611085565b60405190808252806020026020018201604052801561025057816020015b606081526020019060019003908161023b5790505b5090505f5b8751811015610534575f888281518110610271576102716115ee565b0160200151604051638902624560e01b815260f89190911c6004820181905263ffffffff8a16602483015291505f906001600160a01b038716906389026245906044015f60405180830381865afa1580156102ce573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526102f59190810190611602565b905080516001600160401b0381111561031057610310611085565b60405190808252806020026020018201604052801561035957816020015b604080516060810182525f80825260208083018290529282015282525f1990920191018161032e5790505b5084848151811061036c5761036c6115ee565b60209081029190910101525f5b8151811015610529576040518060600160405280876001600160a01b03166347b314e88585815181106103ae576103ae6115ee565b60200260200101516040518263ffffffff1660e01b81526004016103d491815260200190565b602060405180830381865afa1580156103ef573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061041391906115d3565b6001600160a01b03168152602001838381518110610433576104336115ee565b60200260200101518152602001896001600160a01b031663fa28c627858581518110610461576104616115ee565b60209081029190910101516040516001600160e01b031960e084901b168152600481019190915260ff8816602482015263ffffffff8f166044820152606401602060405180830381865afa1580156104bb573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104df9190611692565b6001600160601b03168152508585815181106104fd576104fd6115ee565b60200260200101518281518110610516576105166115ee565b6020908102919091010152600101610379565b505050600101610255565b50979650505050505050565b61056b6040518060800160405280606081526020016060815260200160608152602001606081525090565b5f876001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105a8573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105cc91906115d3565b90506105f96040518060800160405280606081526020016060815260200160608152602001606081525090565b6040516361c8a12f60e11b81526001600160a01b038a169063c391425e90610629908b90899089906004016116b8565b5f60405180830381865afa158015610643573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261066a91908101906116fd565b81526040516340e03a8160e11b81526001600160a01b038316906381c075029061069c908b908b908b906004016117b4565b5f60405180830381865afa1580156106b6573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526106dd91908101906116fd565b6040820152856001600160401b038111156106fa576106fa611085565b60405190808252806020026020018201604052801561072d57816020015b60608152602001906001900390816107185790505b5060608201525f5b60ff8116871115610b52575f856001600160401b0381111561075957610759611085565b604051908082528060200260200182016040528015610782578160200160208202803683370190505b5083606001518360ff168151811061079c5761079c6115ee565b60209081029190910101525f5b86811015610a5e575f8c6001600160a01b03166304ec63518a8a858181106107d3576107d36115ee565b905060200201358e885f015186815181106107f0576107f06115ee565b60200260200101516040518463ffffffff1660e01b815260040161082d9392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015610848573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061086c91906117dc565b9050806001600160c01b03165f036109165760405162461bcd60e51b815260206004820152605c60248201527f4f70657261746f7253746174655265747269657665722e676574436865636b5360448201527f69676e617475726573496e64696365733a206f70657261746f72206d7573742060648201527f6265207265676973746572656420617420626c6f636b6e756d62657200000000608482015260a40160405180910390fd5b8a8a8560ff1681811061092b5761092b6115ee565b60016001600160c01b038516919093013560f81c1c82169091039050610a5557856001600160a01b031663dd9846b98a8a8581811061096c5761096c6115ee565b905060200201358d8d8860ff16818110610988576109886115ee565b6040516001600160e01b031960e087901b1681526004810194909452919091013560f81c60248301525063ffffffff8f166044820152606401602060405180830381865afa1580156109dc573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a009190611802565b85606001518560ff1681518110610a1957610a196115ee565b60200260200101518481518110610a3257610a326115ee565b63ffffffff9092166020928302919091019091015282610a5181611831565b9350505b506001016107a9565b505f816001600160401b03811115610a7857610a78611085565b604051908082528060200260200182016040528015610aa1578160200160208202803683370190505b5090505f5b82811015610b175784606001518460ff1681518110610ac757610ac76115ee565b60200260200101518181518110610ae057610ae06115ee565b6020026020010151828281518110610afa57610afa6115ee565b63ffffffff90921660209283029190910190910152600101610aa6565b508084606001518460ff1681518110610b3257610b326115ee565b602002602001018190525050508080610b4a90611849565b915050610735565b505f896001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b90573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bb491906115d3565b60405163354952a360e21b81529091506001600160a01b0382169063d5254a8c90610be7908b908b908e90600401611867565b5f60405180830381865afa158015610c01573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610c2891908101906116fd565b60208301525098975050505050505050565b60605f846001600160a01b031663c391425e84866040518363ffffffff1660e01b8152600401610c6b929190611890565b5f60405180830381865afa158015610c85573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610cac91908101906116fd565b90505f84516001600160401b03811115610cc857610cc8611085565b604051908082528060200260200182016040528015610cf1578160200160208202803683370190505b5090505f5b8551811015610de557866001600160a01b03166304ec6351878381518110610d2057610d206115ee565b602002602001015187868581518110610d3b57610d3b6115ee565b60200260200101516040518463ffffffff1660e01b8152600401610d789392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015610d93573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610db791906117dc565b6001600160c01b0316828281518110610dd257610dd26115ee565b6020908102919091010152600101610cf6565b5095945050505050565b6040805160018082528183019092525f9160609183916020808301908036833701905050905084815f81518110610e2857610e286115ee565b60209081029190910101526040516361c8a12f60e11b81525f906001600160a01b0388169063c391425e90610e639088908690600401611890565b5f60405180830381865afa158015610e7d573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610ea491908101906116fd565b5f81518110610eb557610eb56115ee565b60209081029190910101516040516304ec635160e01b81526004810188905263ffffffff87811660248301529091166044820181905291505f906001600160a01b038916906304ec635190606401602060405180830381865afa158015610f1e573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610f4291906117dc565b6001600160c01b031690505f610f5782610f75565b905081610f658a838a6100d8565b9550955050505050935093915050565b60605f5f610f828461103e565b61ffff166001600160401b03811115610f9d57610f9d611085565b6040519080825280601f01601f191660200182016040528015610fc7576020820181803683370190505b5090505f805b825182108015610fde575061010081105b15611034576001811b935085841615611024578060f81b838381518110611007576110076115ee565b60200101906001600160f81b03191690815f1a9053508160010191505b61102d81611831565b9050610fcd565b5090949350505050565b5f805b8215611068576110526001846118d7565b9092169180611060816118ea565b915050611041565b92915050565b6001600160a01b0381168114611082575f5ffd5b50565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b03811182821017156110c1576110c1611085565b604052919050565b63ffffffff81168114611082575f5ffd5b80356110e5816110c9565b919050565b5f5f5f606084860312156110fc575f5ffd5b83356111078161106e565b925060208401356001600160401b03811115611121575f5ffd5b8401601f81018613611131575f5ffd5b80356001600160401b0381111561114a5761114a611085565b61115d601f8201601f1916602001611099565b818152876020838501011115611171575f5ffd5b816020840160208301375f60208383010152809450505050611195604085016110da565b90509250925092565b5f82825180855260208501945060208160051b830101602085015f5b8381101561123f57848303601f19018852815180518085526020918201918501905f5b8181101561122657835180516001600160a01b03168452602080820151818601526040918201516001600160601b031691850191909152909301926060909201916001016111dd565b50506020998a01999094509290920191506001016111ba565b50909695505050505050565b602081525f61125d602083018461119e565b9392505050565b5f5f83601f840112611274575f5ffd5b5081356001600160401b0381111561128a575f5ffd5b6020830191508360208260051b85010111156112a4575f5ffd5b9250929050565b5f5f5f5f5f5f608087890312156112c0575f5ffd5b86356112cb8161106e565b955060208701356112db816110c9565b945060408701356001600160401b038111156112f5575f5ffd5b8701601f81018913611305575f5ffd5b80356001600160401b0381111561131a575f5ffd5b89602082840101111561132b575f5ffd5b6020919091019450925060608701356001600160401b0381111561134d575f5ffd5b61135989828a01611264565b979a9699509497509295939492505050565b5f8151808452602084019350602083015f5b828110156113a157815163ffffffff1686526020958601959091019060010161137d565b5093949350505050565b602081525f8251608060208401526113c660a084018261136b565b90506020840151601f198483030160408501526113e3828261136b565b9150506040840151601f19848303016060850152611401828261136b565b6060860151858203601f190160808701528051808352919350602090810192508084019190600582901b8501015f5b8281101561053457601f1986830301845261144c82865161136b565b60209586019594909401939150600101611430565b5f6001600160401b0382111561147957611479611085565b5060051b60200190565b5f5f5f60608486031215611495575f5ffd5b83356114a08161106e565b925060208401356001600160401b038111156114ba575f5ffd5b8401601f810186136114ca575f5ffd5b80356114dd6114d882611461565b611099565b8082825260208201915060208360051b8501019250888311156114fe575f5ffd5b6020840193505b82841015611520578335825260209384019390910190611505565b945061119592505050604085016110da565b602080825282518282018190525f918401906040840190835b8181101561156957835183526020938401939092019160010161154b565b509095945050505050565b5f5f5f60608486031215611586575f5ffd5b83356115918161106e565b92506020840135915060408401356115a8816110c9565b809150509250925092565b828152604060208201525f6115cb604083018461119e565b949350505050565b5f602082840312156115e3575f5ffd5b815161125d8161106e565b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215611612575f5ffd5b81516001600160401b03811115611627575f5ffd5b8201601f81018413611637575f5ffd5b80516116456114d882611461565b8082825260208201915060208360051b850101925086831115611666575f5ffd5b6020840193505b8284101561168857835182526020938401939091019061166d565b9695505050505050565b5f602082840312156116a2575f5ffd5b81516001600160601b038116811461125d575f5ffd5b63ffffffff8416815260406020820181905281018290525f6001600160fb1b038311156116e3575f5ffd5b8260051b8085606085013791909101606001949350505050565b5f6020828403121561170d575f5ffd5b81516001600160401b03811115611722575f5ffd5b8201601f81018413611732575f5ffd5b80516117406114d882611461565b8082825260208201915060208360051b850101925086831115611761575f5ffd5b6020840193505b8284101561168857835161177b816110c9565b825260209384019390910190611768565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b63ffffffff84168152604060208201525f6117d360408301848661178c565b95945050505050565b5f602082840312156117ec575f5ffd5b81516001600160c01b038116811461125d575f5ffd5b5f60208284031215611812575f5ffd5b815161125d816110c9565b634e487b7160e01b5f52601160045260245ffd5b5f600182016118425761184261181d565b5060010190565b5f60ff821660ff810361185e5761185e61181d565b60010192915050565b604081525f61187a60408301858761178c565b905063ffffffff83166020830152949350505050565b5f6040820163ffffffff85168352604060208401528084518083526060850191506020860192505f5b8181101561123f5783518352602093840193909201916001016118b9565b818103818111156110685761106861181d565b5f61ffff821661ffff810361185e5761185e61181d56fea2646970667358221220983a7507ffb03d68ff5e42423434b107b2a2512a8e9989037206f78712fcd7ed64736f6c634300081b0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15`\x0EW__\xFD[Pa\x197\x80a\0\x1C_9_\xF3\xFE`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0JW_5`\xE0\x1C\x80c5c\xB0\xD1\x14a\0NW\x80cOs\x9Ft\x14a\0wW\x80c\\\x15Vb\x14a\0\x97W\x80c\xCE\xFD\xC1\xD4\x14a\0\xB7W[__\xFD[a\0aa\0\\6`\x04a\x10\xEAV[a\0\xD8V[`@Qa\0n\x91\x90a\x12KV[`@Q\x80\x91\x03\x90\xF3[a\0\x8Aa\0\x856`\x04a\x12\xABV[a\x05@V[`@Qa\0n\x91\x90a\x13\xABV[a\0\xAAa\0\xA56`\x04a\x14\x83V[a\x0C:V[`@Qa\0n\x91\x90a\x152V[a\0\xCAa\0\xC56`\x04a\x15tV[a\r\xEFV[`@Qa\0n\x92\x91\x90a\x15\xB3V[``_\x84`\x01`\x01`\xA0\x1B\x03\x16ch0H5`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01\x17W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01;\x91\x90a\x15\xD3V[\x90P_\x85`\x01`\x01`\xA0\x1B\x03\x16c\x9E\x99#\xC2`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01zW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\x9E\x91\x90a\x15\xD3V[\x90P_\x86`\x01`\x01`\xA0\x1B\x03\x16c]\xF4YF`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01\xDDW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\x01\x91\x90a\x15\xD3V[\x90P_\x86Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02\x1DWa\x02\x1Da\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x02PW\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x02;W\x90P[P\x90P_[\x87Q\x81\x10\x15a\x054W_\x88\x82\x81Q\x81\x10a\x02qWa\x02qa\x15\xEEV[\x01` \x01Q`@Qc\x89\x02bE`\xE0\x1B\x81R`\xF8\x91\x90\x91\x1C`\x04\x82\x01\x81\x90Rc\xFF\xFF\xFF\xFF\x8A\x16`$\x83\x01R\x91P_\x90`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c\x89\x02bE\x90`D\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\xCEW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x02\xF5\x91\x90\x81\x01\x90a\x16\x02V[\x90P\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x03\x10Wa\x03\x10a\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x03YW\x81` \x01[`@\x80Q``\x81\x01\x82R_\x80\x82R` \x80\x83\x01\x82\x90R\x92\x82\x01R\x82R_\x19\x90\x92\x01\x91\x01\x81a\x03.W\x90P[P\x84\x84\x81Q\x81\x10a\x03lWa\x03la\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R_[\x81Q\x81\x10\x15a\x05)W`@Q\x80``\x01`@R\x80\x87`\x01`\x01`\xA0\x1B\x03\x16cG\xB3\x14\xE8\x85\x85\x81Q\x81\x10a\x03\xAEWa\x03\xAEa\x15\xEEV[` \x02` \x01\x01Q`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x03\xD4\x91\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03\xEFW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04\x13\x91\x90a\x15\xD3V[`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x83\x83\x81Q\x81\x10a\x043Wa\x043a\x15\xEEV[` \x02` \x01\x01Q\x81R` \x01\x89`\x01`\x01`\xA0\x1B\x03\x16c\xFA(\xC6'\x85\x85\x81Q\x81\x10a\x04aWa\x04aa\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xE0\x1B\x03\x19`\xE0\x84\x90\x1B\x16\x81R`\x04\x81\x01\x91\x90\x91R`\xFF\x88\x16`$\x82\x01Rc\xFF\xFF\xFF\xFF\x8F\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\xBBW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04\xDF\x91\x90a\x16\x92V[`\x01`\x01``\x1B\x03\x16\x81RP\x85\x85\x81Q\x81\x10a\x04\xFDWa\x04\xFDa\x15\xEEV[` \x02` \x01\x01Q\x82\x81Q\x81\x10a\x05\x16Wa\x05\x16a\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x03yV[PPP`\x01\x01a\x02UV[P\x97\x96PPPPPPPV[a\x05k`@Q\x80`\x80\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[_\x87`\x01`\x01`\xA0\x1B\x03\x16ch0H5`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xA8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xCC\x91\x90a\x15\xD3V[\x90Pa\x05\xF9`@Q\x80`\x80\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Qca\xC8\xA1/`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x8A\x16\x90c\xC3\x91B^\x90a\x06)\x90\x8B\x90\x89\x90\x89\x90`\x04\x01a\x16\xB8V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06CW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x06j\x91\x90\x81\x01\x90a\x16\xFDV[\x81R`@Qc@\xE0:\x81`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\x81\xC0u\x02\x90a\x06\x9C\x90\x8B\x90\x8B\x90\x8B\x90`\x04\x01a\x17\xB4V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\xB6W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x06\xDD\x91\x90\x81\x01\x90a\x16\xFDV[`@\x82\x01R\x85`\x01`\x01`@\x1B\x03\x81\x11\x15a\x06\xFAWa\x06\xFAa\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07-W\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x07\x18W\x90P[P``\x82\x01R_[`\xFF\x81\x16\x87\x11\x15a\x0BRW_\x85`\x01`\x01`@\x1B\x03\x81\x11\x15a\x07YWa\x07Ya\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07\x82W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x83``\x01Q\x83`\xFF\x16\x81Q\x81\x10a\x07\x9CWa\x07\x9Ca\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R_[\x86\x81\x10\x15a\n^W_\x8C`\x01`\x01`\xA0\x1B\x03\x16c\x04\xECcQ\x8A\x8A\x85\x81\x81\x10a\x07\xD3Wa\x07\xD3a\x15\xEEV[\x90P` \x02\x015\x8E\x88_\x01Q\x86\x81Q\x81\x10a\x07\xF0Wa\x07\xF0a\x15\xEEV[` \x02` \x01\x01Q`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x08-\x93\x92\x91\x90\x92\x83Rc\xFF\xFF\xFF\xFF\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08HW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08l\x91\x90a\x17\xDCV[\x90P\x80`\x01`\x01`\xC0\x1B\x03\x16_\x03a\t\x16W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\\`$\x82\x01R\x7FOperatorStateRetriever.getCheckS`D\x82\x01R\x7FignaturesIndices: operator must `d\x82\x01R\x7Fbe registered at blocknumber\0\0\0\0`\x84\x82\x01R`\xA4\x01`@Q\x80\x91\x03\x90\xFD[\x8A\x8A\x85`\xFF\x16\x81\x81\x10a\t+Wa\t+a\x15\xEEV[`\x01`\x01`\x01`\xC0\x1B\x03\x85\x16\x91\x90\x93\x015`\xF8\x1C\x1C\x82\x16\x90\x91\x03\x90Pa\nUW\x85`\x01`\x01`\xA0\x1B\x03\x16c\xDD\x98F\xB9\x8A\x8A\x85\x81\x81\x10a\tlWa\tla\x15\xEEV[\x90P` \x02\x015\x8D\x8D\x88`\xFF\x16\x81\x81\x10a\t\x88Wa\t\x88a\x15\xEEV[`@Q`\x01`\x01`\xE0\x1B\x03\x19`\xE0\x87\x90\x1B\x16\x81R`\x04\x81\x01\x94\x90\x94R\x91\x90\x91\x015`\xF8\x1C`$\x83\x01RPc\xFF\xFF\xFF\xFF\x8F\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\xDCW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\0\x91\x90a\x18\x02V[\x85``\x01Q\x85`\xFF\x16\x81Q\x81\x10a\n\x19Wa\n\x19a\x15\xEEV[` \x02` \x01\x01Q\x84\x81Q\x81\x10a\n2Wa\n2a\x15\xEEV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x82a\nQ\x81a\x181V[\x93PP[P`\x01\x01a\x07\xA9V[P_\x81`\x01`\x01`@\x1B\x03\x81\x11\x15a\nxWa\nxa\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\n\xA1W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x82\x81\x10\x15a\x0B\x17W\x84``\x01Q\x84`\xFF\x16\x81Q\x81\x10a\n\xC7Wa\n\xC7a\x15\xEEV[` \x02` \x01\x01Q\x81\x81Q\x81\x10a\n\xE0Wa\n\xE0a\x15\xEEV[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10a\n\xFAWa\n\xFAa\x15\xEEV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\n\xA6V[P\x80\x84``\x01Q\x84`\xFF\x16\x81Q\x81\x10a\x0B2Wa\x0B2a\x15\xEEV[` \x02` \x01\x01\x81\x90RPPP\x80\x80a\x0BJ\x90a\x18IV[\x91PPa\x075V[P_\x89`\x01`\x01`\xA0\x1B\x03\x16c]\xF4YF`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\x90W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xB4\x91\x90a\x15\xD3V[`@Qc5IR\xA3`\xE2\x1B\x81R\x90\x91P`\x01`\x01`\xA0\x1B\x03\x82\x16\x90c\xD5%J\x8C\x90a\x0B\xE7\x90\x8B\x90\x8B\x90\x8E\x90`\x04\x01a\x18gV[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\x01W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x0C(\x91\x90\x81\x01\x90a\x16\xFDV[` \x83\x01RP\x98\x97PPPPPPPPV[``_\x84`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x91B^\x84\x86`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0Ck\x92\x91\x90a\x18\x90V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\x85W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x0C\xAC\x91\x90\x81\x01\x90a\x16\xFDV[\x90P_\x84Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x0C\xC8Wa\x0C\xC8a\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0C\xF1W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x85Q\x81\x10\x15a\r\xE5W\x86`\x01`\x01`\xA0\x1B\x03\x16c\x04\xECcQ\x87\x83\x81Q\x81\x10a\r Wa\r a\x15\xEEV[` \x02` \x01\x01Q\x87\x86\x85\x81Q\x81\x10a\r;Wa\r;a\x15\xEEV[` \x02` \x01\x01Q`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rx\x93\x92\x91\x90\x92\x83Rc\xFF\xFF\xFF\xFF\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x93W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xB7\x91\x90a\x17\xDCV[`\x01`\x01`\xC0\x1B\x03\x16\x82\x82\x81Q\x81\x10a\r\xD2Wa\r\xD2a\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x0C\xF6V[P\x95\x94PPPPPV[`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R_\x91``\x91\x83\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x84\x81_\x81Q\x81\x10a\x0E(Wa\x0E(a\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R`@Qca\xC8\xA1/`\xE1\x1B\x81R_\x90`\x01`\x01`\xA0\x1B\x03\x88\x16\x90c\xC3\x91B^\x90a\x0Ec\x90\x88\x90\x86\x90`\x04\x01a\x18\x90V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0E}W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x0E\xA4\x91\x90\x81\x01\x90a\x16\xFDV[_\x81Q\x81\x10a\x0E\xB5Wa\x0E\xB5a\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Qc\x04\xECcQ`\xE0\x1B\x81R`\x04\x81\x01\x88\x90Rc\xFF\xFF\xFF\xFF\x87\x81\x16`$\x83\x01R\x90\x91\x16`D\x82\x01\x81\x90R\x91P_\x90`\x01`\x01`\xA0\x1B\x03\x89\x16\x90c\x04\xECcQ\x90`d\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0F\x1EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0FB\x91\x90a\x17\xDCV[`\x01`\x01`\xC0\x1B\x03\x16\x90P_a\x0FW\x82a\x0FuV[\x90P\x81a\x0Fe\x8A\x83\x8Aa\0\xD8V[\x95P\x95PPPPP\x93P\x93\x91PPV[``__a\x0F\x82\x84a\x10>V[a\xFF\xFF\x16`\x01`\x01`@\x1B\x03\x81\x11\x15a\x0F\x9DWa\x0F\x9Da\x10\x85V[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x0F\xC7W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P_\x80[\x82Q\x82\x10\x80\x15a\x0F\xDEWPa\x01\0\x81\x10[\x15a\x104W`\x01\x81\x1B\x93P\x85\x84\x16\x15a\x10$W\x80`\xF8\x1B\x83\x83\x81Q\x81\x10a\x10\x07Wa\x10\x07a\x15\xEEV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP\x81`\x01\x01\x91P[a\x10-\x81a\x181V[\x90Pa\x0F\xCDV[P\x90\x94\x93PPPPV[_\x80[\x82\x15a\x10hWa\x10R`\x01\x84a\x18\xD7V[\x90\x92\x16\x91\x80a\x10`\x81a\x18\xEAV[\x91PPa\x10AV[\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x10\x82W__\xFD[PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x10\xC1Wa\x10\xC1a\x10\x85V[`@R\x91\x90PV[c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x10\x82W__\xFD[\x805a\x10\xE5\x81a\x10\xC9V[\x91\x90PV[___``\x84\x86\x03\x12\x15a\x10\xFCW__\xFD[\x835a\x11\x07\x81a\x10nV[\x92P` \x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\x11!W__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x111W__\xFD[\x805`\x01`\x01`@\x1B\x03\x81\x11\x15a\x11JWa\x11Ja\x10\x85V[a\x11]`\x1F\x82\x01`\x1F\x19\x16` \x01a\x10\x99V[\x81\x81R\x87` \x83\x85\x01\x01\x11\x15a\x11qW__\xFD[\x81` \x84\x01` \x83\x017_` \x83\x83\x01\x01R\x80\x94PPPPa\x11\x95`@\x85\x01a\x10\xDAV[\x90P\x92P\x92P\x92V[_\x82\x82Q\x80\x85R` \x85\x01\x94P` \x81`\x05\x1B\x83\x01\x01` \x85\x01_[\x83\x81\x10\x15a\x12?W\x84\x83\x03`\x1F\x19\x01\x88R\x81Q\x80Q\x80\x85R` \x91\x82\x01\x91\x85\x01\x90_[\x81\x81\x10\x15a\x12&W\x83Q\x80Q`\x01`\x01`\xA0\x1B\x03\x16\x84R` \x80\x82\x01Q\x81\x86\x01R`@\x91\x82\x01Q`\x01`\x01``\x1B\x03\x16\x91\x85\x01\x91\x90\x91R\x90\x93\x01\x92``\x90\x92\x01\x91`\x01\x01a\x11\xDDV[PP` \x99\x8A\x01\x99\x90\x94P\x92\x90\x92\x01\x91P`\x01\x01a\x11\xBAV[P\x90\x96\x95PPPPPPV[` \x81R_a\x12]` \x83\x01\x84a\x11\x9EV[\x93\x92PPPV[__\x83`\x1F\x84\x01\x12a\x12tW__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a\x12\x8AW__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x12\xA4W__\xFD[\x92P\x92\x90PV[______`\x80\x87\x89\x03\x12\x15a\x12\xC0W__\xFD[\x865a\x12\xCB\x81a\x10nV[\x95P` \x87\x015a\x12\xDB\x81a\x10\xC9V[\x94P`@\x87\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\x12\xF5W__\xFD[\x87\x01`\x1F\x81\x01\x89\x13a\x13\x05W__\xFD[\x805`\x01`\x01`@\x1B\x03\x81\x11\x15a\x13\x1AW__\xFD[\x89` \x82\x84\x01\x01\x11\x15a\x13+W__\xFD[` \x91\x90\x91\x01\x94P\x92P``\x87\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\x13MW__\xFD[a\x13Y\x89\x82\x8A\x01a\x12dV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a\x13\xA1W\x81Qc\xFF\xFF\xFF\xFF\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x13}V[P\x93\x94\x93PPPPV[` \x81R_\x82Q`\x80` \x84\x01Ra\x13\xC6`\xA0\x84\x01\x82a\x13kV[\x90P` \x84\x01Q`\x1F\x19\x84\x83\x03\x01`@\x85\x01Ra\x13\xE3\x82\x82a\x13kV[\x91PP`@\x84\x01Q`\x1F\x19\x84\x83\x03\x01``\x85\x01Ra\x14\x01\x82\x82a\x13kV[``\x86\x01Q\x85\x82\x03`\x1F\x19\x01`\x80\x87\x01R\x80Q\x80\x83R\x91\x93P` \x90\x81\x01\x92P\x80\x84\x01\x91\x90`\x05\x82\x90\x1B\x85\x01\x01_[\x82\x81\x10\x15a\x054W`\x1F\x19\x86\x83\x03\x01\x84Ra\x14L\x82\x86Qa\x13kV[` \x95\x86\x01\x95\x94\x90\x94\x01\x93\x91P`\x01\x01a\x140V[_`\x01`\x01`@\x1B\x03\x82\x11\x15a\x14yWa\x14ya\x10\x85V[P`\x05\x1B` \x01\x90V[___``\x84\x86\x03\x12\x15a\x14\x95W__\xFD[\x835a\x14\xA0\x81a\x10nV[\x92P` \x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\x14\xBAW__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x14\xCAW__\xFD[\x805a\x14\xDDa\x14\xD8\x82a\x14aV[a\x10\x99V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x88\x83\x11\x15a\x14\xFEW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a\x15 W\x835\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a\x15\x05V[\x94Pa\x11\x95\x92PPP`@\x85\x01a\x10\xDAV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x15iW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x15KV[P\x90\x95\x94PPPPPV[___``\x84\x86\x03\x12\x15a\x15\x86W__\xFD[\x835a\x15\x91\x81a\x10nV[\x92P` \x84\x015\x91P`@\x84\x015a\x15\xA8\x81a\x10\xC9V[\x80\x91PP\x92P\x92P\x92V[\x82\x81R`@` \x82\x01R_a\x15\xCB`@\x83\x01\x84a\x11\x9EV[\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x15\xE3W__\xFD[\x81Qa\x12]\x81a\x10nV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a\x16\x12W__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x16'W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x167W__\xFD[\x80Qa\x16Ea\x14\xD8\x82a\x14aV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x86\x83\x11\x15a\x16fW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a\x16\x88W\x83Q\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a\x16mV[\x96\x95PPPPPPV[_` \x82\x84\x03\x12\x15a\x16\xA2W__\xFD[\x81Q`\x01`\x01``\x1B\x03\x81\x16\x81\x14a\x12]W__\xFD[c\xFF\xFF\xFF\xFF\x84\x16\x81R`@` \x82\x01\x81\x90R\x81\x01\x82\x90R_`\x01`\x01`\xFB\x1B\x03\x83\x11\x15a\x16\xE3W__\xFD[\x82`\x05\x1B\x80\x85``\x85\x017\x91\x90\x91\x01``\x01\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x17\rW__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x17\"W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x172W__\xFD[\x80Qa\x17@a\x14\xD8\x82a\x14aV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x86\x83\x11\x15a\x17aW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a\x16\x88W\x83Qa\x17{\x81a\x10\xC9V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a\x17hV[\x81\x83R\x81\x81` \x85\x017P_\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1F\x90\x91\x01`\x1F\x19\x16\x90\x91\x01\x01\x90V[c\xFF\xFF\xFF\xFF\x84\x16\x81R`@` \x82\x01R_a\x17\xD3`@\x83\x01\x84\x86a\x17\x8CV[\x95\x94PPPPPV[_` \x82\x84\x03\x12\x15a\x17\xECW__\xFD[\x81Q`\x01`\x01`\xC0\x1B\x03\x81\x16\x81\x14a\x12]W__\xFD[_` \x82\x84\x03\x12\x15a\x18\x12W__\xFD[\x81Qa\x12]\x81a\x10\xC9V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_`\x01\x82\x01a\x18BWa\x18Ba\x18\x1DV[P`\x01\x01\x90V[_`\xFF\x82\x16`\xFF\x81\x03a\x18^Wa\x18^a\x18\x1DV[`\x01\x01\x92\x91PPV[`@\x81R_a\x18z`@\x83\x01\x85\x87a\x17\x8CV[\x90Pc\xFF\xFF\xFF\xFF\x83\x16` \x83\x01R\x94\x93PPPPV[_`@\x82\x01c\xFF\xFF\xFF\xFF\x85\x16\x83R`@` \x84\x01R\x80\x84Q\x80\x83R``\x85\x01\x91P` \x86\x01\x92P_[\x81\x81\x10\x15a\x12?W\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x18\xB9V[\x81\x81\x03\x81\x81\x11\x15a\x10hWa\x10ha\x18\x1DV[_a\xFF\xFF\x82\x16a\xFF\xFF\x81\x03a\x18^Wa\x18^a\x18\x1DV\xFE\xA2dipfsX\"\x12 \x98:u\x07\xFF\xB0=h\xFF^BB44\xB1\x07\xB2\xA2Q*\x8E\x99\x89\x03r\x06\xF7\x87\x12\xFC\xD7\xEDdsolcC\0\x08\x1B\x003",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x608060405234801561000f575f5ffd5b506004361061004a575f3560e01c80633563b0d11461004e5780634f739f74146100775780635c15566214610097578063cefdc1d4146100b7575b5f5ffd5b61006161005c3660046110ea565b6100d8565b60405161006e919061124b565b60405180910390f35b61008a6100853660046112ab565b610540565b60405161006e91906113ab565b6100aa6100a5366004611483565b610c3a565b60405161006e9190611532565b6100ca6100c5366004611574565b610def565b60405161006e9291906115b3565b60605f846001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa158015610117573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061013b91906115d3565b90505f856001600160a01b0316639e9923c26040518163ffffffff1660e01b8152600401602060405180830381865afa15801561017a573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061019e91906115d3565b90505f866001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa1580156101dd573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061020191906115d3565b90505f86516001600160401b0381111561021d5761021d611085565b60405190808252806020026020018201604052801561025057816020015b606081526020019060019003908161023b5790505b5090505f5b8751811015610534575f888281518110610271576102716115ee565b0160200151604051638902624560e01b815260f89190911c6004820181905263ffffffff8a16602483015291505f906001600160a01b038716906389026245906044015f60405180830381865afa1580156102ce573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526102f59190810190611602565b905080516001600160401b0381111561031057610310611085565b60405190808252806020026020018201604052801561035957816020015b604080516060810182525f80825260208083018290529282015282525f1990920191018161032e5790505b5084848151811061036c5761036c6115ee565b60209081029190910101525f5b8151811015610529576040518060600160405280876001600160a01b03166347b314e88585815181106103ae576103ae6115ee565b60200260200101516040518263ffffffff1660e01b81526004016103d491815260200190565b602060405180830381865afa1580156103ef573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061041391906115d3565b6001600160a01b03168152602001838381518110610433576104336115ee565b60200260200101518152602001896001600160a01b031663fa28c627858581518110610461576104616115ee565b60209081029190910101516040516001600160e01b031960e084901b168152600481019190915260ff8816602482015263ffffffff8f166044820152606401602060405180830381865afa1580156104bb573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906104df9190611692565b6001600160601b03168152508585815181106104fd576104fd6115ee565b60200260200101518281518110610516576105166115ee565b6020908102919091010152600101610379565b505050600101610255565b50979650505050505050565b61056b6040518060800160405280606081526020016060815260200160608152602001606081525090565b5f876001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105a8573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906105cc91906115d3565b90506105f96040518060800160405280606081526020016060815260200160608152602001606081525090565b6040516361c8a12f60e11b81526001600160a01b038a169063c391425e90610629908b90899089906004016116b8565b5f60405180830381865afa158015610643573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f1916820160405261066a91908101906116fd565b81526040516340e03a8160e11b81526001600160a01b038316906381c075029061069c908b908b908b906004016117b4565b5f60405180830381865afa1580156106b6573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f191682016040526106dd91908101906116fd565b6040820152856001600160401b038111156106fa576106fa611085565b60405190808252806020026020018201604052801561072d57816020015b60608152602001906001900390816107185790505b5060608201525f5b60ff8116871115610b52575f856001600160401b0381111561075957610759611085565b604051908082528060200260200182016040528015610782578160200160208202803683370190505b5083606001518360ff168151811061079c5761079c6115ee565b60209081029190910101525f5b86811015610a5e575f8c6001600160a01b03166304ec63518a8a858181106107d3576107d36115ee565b905060200201358e885f015186815181106107f0576107f06115ee565b60200260200101516040518463ffffffff1660e01b815260040161082d9392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015610848573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061086c91906117dc565b9050806001600160c01b03165f036109165760405162461bcd60e51b815260206004820152605c60248201527f4f70657261746f7253746174655265747269657665722e676574436865636b5360448201527f69676e617475726573496e64696365733a206f70657261746f72206d7573742060648201527f6265207265676973746572656420617420626c6f636b6e756d62657200000000608482015260a40160405180910390fd5b8a8a8560ff1681811061092b5761092b6115ee565b60016001600160c01b038516919093013560f81c1c82169091039050610a5557856001600160a01b031663dd9846b98a8a8581811061096c5761096c6115ee565b905060200201358d8d8860ff16818110610988576109886115ee565b6040516001600160e01b031960e087901b1681526004810194909452919091013560f81c60248301525063ffffffff8f166044820152606401602060405180830381865afa1580156109dc573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610a009190611802565b85606001518560ff1681518110610a1957610a196115ee565b60200260200101518481518110610a3257610a326115ee565b63ffffffff9092166020928302919091019091015282610a5181611831565b9350505b506001016107a9565b505f816001600160401b03811115610a7857610a78611085565b604051908082528060200260200182016040528015610aa1578160200160208202803683370190505b5090505f5b82811015610b175784606001518460ff1681518110610ac757610ac76115ee565b60200260200101518181518110610ae057610ae06115ee565b6020026020010151828281518110610afa57610afa6115ee565b63ffffffff90921660209283029190910190910152600101610aa6565b508084606001518460ff1681518110610b3257610b326115ee565b602002602001018190525050508080610b4a90611849565b915050610735565b505f896001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b90573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bb491906115d3565b60405163354952a360e21b81529091506001600160a01b0382169063d5254a8c90610be7908b908b908e90600401611867565b5f60405180830381865afa158015610c01573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610c2891908101906116fd565b60208301525098975050505050505050565b60605f846001600160a01b031663c391425e84866040518363ffffffff1660e01b8152600401610c6b929190611890565b5f60405180830381865afa158015610c85573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610cac91908101906116fd565b90505f84516001600160401b03811115610cc857610cc8611085565b604051908082528060200260200182016040528015610cf1578160200160208202803683370190505b5090505f5b8551811015610de557866001600160a01b03166304ec6351878381518110610d2057610d206115ee565b602002602001015187868581518110610d3b57610d3b6115ee565b60200260200101516040518463ffffffff1660e01b8152600401610d789392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015610d93573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610db791906117dc565b6001600160c01b0316828281518110610dd257610dd26115ee565b6020908102919091010152600101610cf6565b5095945050505050565b6040805160018082528183019092525f9160609183916020808301908036833701905050905084815f81518110610e2857610e286115ee565b60209081029190910101526040516361c8a12f60e11b81525f906001600160a01b0388169063c391425e90610e639088908690600401611890565b5f60405180830381865afa158015610e7d573d5f5f3e3d5ffd5b505050506040513d5f823e601f3d908101601f19168201604052610ea491908101906116fd565b5f81518110610eb557610eb56115ee565b60209081029190910101516040516304ec635160e01b81526004810188905263ffffffff87811660248301529091166044820181905291505f906001600160a01b038916906304ec635190606401602060405180830381865afa158015610f1e573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610f4291906117dc565b6001600160c01b031690505f610f5782610f75565b905081610f658a838a6100d8565b9550955050505050935093915050565b60605f5f610f828461103e565b61ffff166001600160401b03811115610f9d57610f9d611085565b6040519080825280601f01601f191660200182016040528015610fc7576020820181803683370190505b5090505f805b825182108015610fde575061010081105b15611034576001811b935085841615611024578060f81b838381518110611007576110076115ee565b60200101906001600160f81b03191690815f1a9053508160010191505b61102d81611831565b9050610fcd565b5090949350505050565b5f805b8215611068576110526001846118d7565b9092169180611060816118ea565b915050611041565b92915050565b6001600160a01b0381168114611082575f5ffd5b50565b634e487b7160e01b5f52604160045260245ffd5b604051601f8201601f191681016001600160401b03811182821017156110c1576110c1611085565b604052919050565b63ffffffff81168114611082575f5ffd5b80356110e5816110c9565b919050565b5f5f5f606084860312156110fc575f5ffd5b83356111078161106e565b925060208401356001600160401b03811115611121575f5ffd5b8401601f81018613611131575f5ffd5b80356001600160401b0381111561114a5761114a611085565b61115d601f8201601f1916602001611099565b818152876020838501011115611171575f5ffd5b816020840160208301375f60208383010152809450505050611195604085016110da565b90509250925092565b5f82825180855260208501945060208160051b830101602085015f5b8381101561123f57848303601f19018852815180518085526020918201918501905f5b8181101561122657835180516001600160a01b03168452602080820151818601526040918201516001600160601b031691850191909152909301926060909201916001016111dd565b50506020998a01999094509290920191506001016111ba565b50909695505050505050565b602081525f61125d602083018461119e565b9392505050565b5f5f83601f840112611274575f5ffd5b5081356001600160401b0381111561128a575f5ffd5b6020830191508360208260051b85010111156112a4575f5ffd5b9250929050565b5f5f5f5f5f5f608087890312156112c0575f5ffd5b86356112cb8161106e565b955060208701356112db816110c9565b945060408701356001600160401b038111156112f5575f5ffd5b8701601f81018913611305575f5ffd5b80356001600160401b0381111561131a575f5ffd5b89602082840101111561132b575f5ffd5b6020919091019450925060608701356001600160401b0381111561134d575f5ffd5b61135989828a01611264565b979a9699509497509295939492505050565b5f8151808452602084019350602083015f5b828110156113a157815163ffffffff1686526020958601959091019060010161137d565b5093949350505050565b602081525f8251608060208401526113c660a084018261136b565b90506020840151601f198483030160408501526113e3828261136b565b9150506040840151601f19848303016060850152611401828261136b565b6060860151858203601f190160808701528051808352919350602090810192508084019190600582901b8501015f5b8281101561053457601f1986830301845261144c82865161136b565b60209586019594909401939150600101611430565b5f6001600160401b0382111561147957611479611085565b5060051b60200190565b5f5f5f60608486031215611495575f5ffd5b83356114a08161106e565b925060208401356001600160401b038111156114ba575f5ffd5b8401601f810186136114ca575f5ffd5b80356114dd6114d882611461565b611099565b8082825260208201915060208360051b8501019250888311156114fe575f5ffd5b6020840193505b82841015611520578335825260209384019390910190611505565b945061119592505050604085016110da565b602080825282518282018190525f918401906040840190835b8181101561156957835183526020938401939092019160010161154b565b509095945050505050565b5f5f5f60608486031215611586575f5ffd5b83356115918161106e565b92506020840135915060408401356115a8816110c9565b809150509250925092565b828152604060208201525f6115cb604083018461119e565b949350505050565b5f602082840312156115e3575f5ffd5b815161125d8161106e565b634e487b7160e01b5f52603260045260245ffd5b5f60208284031215611612575f5ffd5b81516001600160401b03811115611627575f5ffd5b8201601f81018413611637575f5ffd5b80516116456114d882611461565b8082825260208201915060208360051b850101925086831115611666575f5ffd5b6020840193505b8284101561168857835182526020938401939091019061166d565b9695505050505050565b5f602082840312156116a2575f5ffd5b81516001600160601b038116811461125d575f5ffd5b63ffffffff8416815260406020820181905281018290525f6001600160fb1b038311156116e3575f5ffd5b8260051b8085606085013791909101606001949350505050565b5f6020828403121561170d575f5ffd5b81516001600160401b03811115611722575f5ffd5b8201601f81018413611732575f5ffd5b80516117406114d882611461565b8082825260208201915060208360051b850101925086831115611761575f5ffd5b6020840193505b8284101561168857835161177b816110c9565b825260209384019390910190611768565b81835281816020850137505f828201602090810191909152601f909101601f19169091010190565b63ffffffff84168152604060208201525f6117d360408301848661178c565b95945050505050565b5f602082840312156117ec575f5ffd5b81516001600160c01b038116811461125d575f5ffd5b5f60208284031215611812575f5ffd5b815161125d816110c9565b634e487b7160e01b5f52601160045260245ffd5b5f600182016118425761184261181d565b5060010190565b5f60ff821660ff810361185e5761185e61181d565b60010192915050565b604081525f61187a60408301858761178c565b905063ffffffff83166020830152949350505050565b5f6040820163ffffffff85168352604060208401528084518083526060850191506020860192505f5b8181101561123f5783518352602093840193909201916001016118b9565b818103818111156110685761106861181d565b5f61ffff821661ffff810361185e5761185e61181d56fea2646970667358221220983a7507ffb03d68ff5e42423434b107b2a2512a8e9989037206f78712fcd7ed64736f6c634300081b0033
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R4\x80\x15a\0\x0FW__\xFD[P`\x046\x10a\0JW_5`\xE0\x1C\x80c5c\xB0\xD1\x14a\0NW\x80cOs\x9Ft\x14a\0wW\x80c\\\x15Vb\x14a\0\x97W\x80c\xCE\xFD\xC1\xD4\x14a\0\xB7W[__\xFD[a\0aa\0\\6`\x04a\x10\xEAV[a\0\xD8V[`@Qa\0n\x91\x90a\x12KV[`@Q\x80\x91\x03\x90\xF3[a\0\x8Aa\0\x856`\x04a\x12\xABV[a\x05@V[`@Qa\0n\x91\x90a\x13\xABV[a\0\xAAa\0\xA56`\x04a\x14\x83V[a\x0C:V[`@Qa\0n\x91\x90a\x152V[a\0\xCAa\0\xC56`\x04a\x15tV[a\r\xEFV[`@Qa\0n\x92\x91\x90a\x15\xB3V[``_\x84`\x01`\x01`\xA0\x1B\x03\x16ch0H5`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01\x17W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01;\x91\x90a\x15\xD3V[\x90P_\x85`\x01`\x01`\xA0\x1B\x03\x16c\x9E\x99#\xC2`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01zW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x01\x9E\x91\x90a\x15\xD3V[\x90P_\x86`\x01`\x01`\xA0\x1B\x03\x16c]\xF4YF`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x01\xDDW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x02\x01\x91\x90a\x15\xD3V[\x90P_\x86Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x02\x1DWa\x02\x1Da\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x02PW\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x02;W\x90P[P\x90P_[\x87Q\x81\x10\x15a\x054W_\x88\x82\x81Q\x81\x10a\x02qWa\x02qa\x15\xEEV[\x01` \x01Q`@Qc\x89\x02bE`\xE0\x1B\x81R`\xF8\x91\x90\x91\x1C`\x04\x82\x01\x81\x90Rc\xFF\xFF\xFF\xFF\x8A\x16`$\x83\x01R\x91P_\x90`\x01`\x01`\xA0\x1B\x03\x87\x16\x90c\x89\x02bE\x90`D\x01_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x02\xCEW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x02\xF5\x91\x90\x81\x01\x90a\x16\x02V[\x90P\x80Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x03\x10Wa\x03\x10a\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x03YW\x81` \x01[`@\x80Q``\x81\x01\x82R_\x80\x82R` \x80\x83\x01\x82\x90R\x92\x82\x01R\x82R_\x19\x90\x92\x01\x91\x01\x81a\x03.W\x90P[P\x84\x84\x81Q\x81\x10a\x03lWa\x03la\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R_[\x81Q\x81\x10\x15a\x05)W`@Q\x80``\x01`@R\x80\x87`\x01`\x01`\xA0\x1B\x03\x16cG\xB3\x14\xE8\x85\x85\x81Q\x81\x10a\x03\xAEWa\x03\xAEa\x15\xEEV[` \x02` \x01\x01Q`@Q\x82c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x03\xD4\x91\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x03\xEFW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04\x13\x91\x90a\x15\xD3V[`\x01`\x01`\xA0\x1B\x03\x16\x81R` \x01\x83\x83\x81Q\x81\x10a\x043Wa\x043a\x15\xEEV[` \x02` \x01\x01Q\x81R` \x01\x89`\x01`\x01`\xA0\x1B\x03\x16c\xFA(\xC6'\x85\x85\x81Q\x81\x10a\x04aWa\x04aa\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xE0\x1B\x03\x19`\xE0\x84\x90\x1B\x16\x81R`\x04\x81\x01\x91\x90\x91R`\xFF\x88\x16`$\x82\x01Rc\xFF\xFF\xFF\xFF\x8F\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x04\xBBW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x04\xDF\x91\x90a\x16\x92V[`\x01`\x01``\x1B\x03\x16\x81RP\x85\x85\x81Q\x81\x10a\x04\xFDWa\x04\xFDa\x15\xEEV[` \x02` \x01\x01Q\x82\x81Q\x81\x10a\x05\x16Wa\x05\x16a\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x03yV[PPP`\x01\x01a\x02UV[P\x97\x96PPPPPPPV[a\x05k`@Q\x80`\x80\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[_\x87`\x01`\x01`\xA0\x1B\x03\x16ch0H5`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x05\xA8W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x05\xCC\x91\x90a\x15\xD3V[\x90Pa\x05\xF9`@Q\x80`\x80\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Qca\xC8\xA1/`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x8A\x16\x90c\xC3\x91B^\x90a\x06)\x90\x8B\x90\x89\x90\x89\x90`\x04\x01a\x16\xB8V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06CW=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x06j\x91\x90\x81\x01\x90a\x16\xFDV[\x81R`@Qc@\xE0:\x81`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16\x90c\x81\xC0u\x02\x90a\x06\x9C\x90\x8B\x90\x8B\x90\x8B\x90`\x04\x01a\x17\xB4V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x06\xB6W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x06\xDD\x91\x90\x81\x01\x90a\x16\xFDV[`@\x82\x01R\x85`\x01`\x01`@\x1B\x03\x81\x11\x15a\x06\xFAWa\x06\xFAa\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07-W\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x07\x18W\x90P[P``\x82\x01R_[`\xFF\x81\x16\x87\x11\x15a\x0BRW_\x85`\x01`\x01`@\x1B\x03\x81\x11\x15a\x07YWa\x07Ya\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x07\x82W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x83``\x01Q\x83`\xFF\x16\x81Q\x81\x10a\x07\x9CWa\x07\x9Ca\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R_[\x86\x81\x10\x15a\n^W_\x8C`\x01`\x01`\xA0\x1B\x03\x16c\x04\xECcQ\x8A\x8A\x85\x81\x81\x10a\x07\xD3Wa\x07\xD3a\x15\xEEV[\x90P` \x02\x015\x8E\x88_\x01Q\x86\x81Q\x81\x10a\x07\xF0Wa\x07\xF0a\x15\xEEV[` \x02` \x01\x01Q`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x08-\x93\x92\x91\x90\x92\x83Rc\xFF\xFF\xFF\xFF\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x08HW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x08l\x91\x90a\x17\xDCV[\x90P\x80`\x01`\x01`\xC0\x1B\x03\x16_\x03a\t\x16W`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\\`$\x82\x01R\x7FOperatorStateRetriever.getCheckS`D\x82\x01R\x7FignaturesIndices: operator must `d\x82\x01R\x7Fbe registered at blocknumber\0\0\0\0`\x84\x82\x01R`\xA4\x01`@Q\x80\x91\x03\x90\xFD[\x8A\x8A\x85`\xFF\x16\x81\x81\x10a\t+Wa\t+a\x15\xEEV[`\x01`\x01`\x01`\xC0\x1B\x03\x85\x16\x91\x90\x93\x015`\xF8\x1C\x1C\x82\x16\x90\x91\x03\x90Pa\nUW\x85`\x01`\x01`\xA0\x1B\x03\x16c\xDD\x98F\xB9\x8A\x8A\x85\x81\x81\x10a\tlWa\tla\x15\xEEV[\x90P` \x02\x015\x8D\x8D\x88`\xFF\x16\x81\x81\x10a\t\x88Wa\t\x88a\x15\xEEV[`@Q`\x01`\x01`\xE0\x1B\x03\x19`\xE0\x87\x90\x1B\x16\x81R`\x04\x81\x01\x94\x90\x94R\x91\x90\x91\x015`\xF8\x1C`$\x83\x01RPc\xFF\xFF\xFF\xFF\x8F\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\t\xDCW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\0\x91\x90a\x18\x02V[\x85``\x01Q\x85`\xFF\x16\x81Q\x81\x10a\n\x19Wa\n\x19a\x15\xEEV[` \x02` \x01\x01Q\x84\x81Q\x81\x10a\n2Wa\n2a\x15\xEEV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x82a\nQ\x81a\x181V[\x93PP[P`\x01\x01a\x07\xA9V[P_\x81`\x01`\x01`@\x1B\x03\x81\x11\x15a\nxWa\nxa\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\n\xA1W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x82\x81\x10\x15a\x0B\x17W\x84``\x01Q\x84`\xFF\x16\x81Q\x81\x10a\n\xC7Wa\n\xC7a\x15\xEEV[` \x02` \x01\x01Q\x81\x81Q\x81\x10a\n\xE0Wa\n\xE0a\x15\xEEV[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10a\n\xFAWa\n\xFAa\x15\xEEV[c\xFF\xFF\xFF\xFF\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R`\x01\x01a\n\xA6V[P\x80\x84``\x01Q\x84`\xFF\x16\x81Q\x81\x10a\x0B2Wa\x0B2a\x15\xEEV[` \x02` \x01\x01\x81\x90RPPP\x80\x80a\x0BJ\x90a\x18IV[\x91PPa\x075V[P_\x89`\x01`\x01`\xA0\x1B\x03\x16c]\xF4YF`@Q\x81c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0B\x90W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0B\xB4\x91\x90a\x15\xD3V[`@Qc5IR\xA3`\xE2\x1B\x81R\x90\x91P`\x01`\x01`\xA0\x1B\x03\x82\x16\x90c\xD5%J\x8C\x90a\x0B\xE7\x90\x8B\x90\x8B\x90\x8E\x90`\x04\x01a\x18gV[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\x01W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x0C(\x91\x90\x81\x01\x90a\x16\xFDV[` \x83\x01RP\x98\x97PPPPPPPPV[``_\x84`\x01`\x01`\xA0\x1B\x03\x16c\xC3\x91B^\x84\x86`@Q\x83c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\x0Ck\x92\x91\x90a\x18\x90V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0C\x85W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x0C\xAC\x91\x90\x81\x01\x90a\x16\xFDV[\x90P_\x84Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x0C\xC8Wa\x0C\xC8a\x10\x85V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0C\xF1W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P_[\x85Q\x81\x10\x15a\r\xE5W\x86`\x01`\x01`\xA0\x1B\x03\x16c\x04\xECcQ\x87\x83\x81Q\x81\x10a\r Wa\r a\x15\xEEV[` \x02` \x01\x01Q\x87\x86\x85\x81Q\x81\x10a\r;Wa\r;a\x15\xEEV[` \x02` \x01\x01Q`@Q\x84c\xFF\xFF\xFF\xFF\x16`\xE0\x1B\x81R`\x04\x01a\rx\x93\x92\x91\x90\x92\x83Rc\xFF\xFF\xFF\xFF\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\r\x93W=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\xB7\x91\x90a\x17\xDCV[`\x01`\x01`\xC0\x1B\x03\x16\x82\x82\x81Q\x81\x10a\r\xD2Wa\r\xD2a\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R`\x01\x01a\x0C\xF6V[P\x95\x94PPPPPV[`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R_\x91``\x91\x83\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x84\x81_\x81Q\x81\x10a\x0E(Wa\x0E(a\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01R`@Qca\xC8\xA1/`\xE1\x1B\x81R_\x90`\x01`\x01`\xA0\x1B\x03\x88\x16\x90c\xC3\x91B^\x90a\x0Ec\x90\x88\x90\x86\x90`\x04\x01a\x18\x90V[_`@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0E}W=__>=_\xFD[PPPP`@Q=_\x82>`\x1F=\x90\x81\x01`\x1F\x19\x16\x82\x01`@Ra\x0E\xA4\x91\x90\x81\x01\x90a\x16\xFDV[_\x81Q\x81\x10a\x0E\xB5Wa\x0E\xB5a\x15\xEEV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Qc\x04\xECcQ`\xE0\x1B\x81R`\x04\x81\x01\x88\x90Rc\xFF\xFF\xFF\xFF\x87\x81\x16`$\x83\x01R\x90\x91\x16`D\x82\x01\x81\x90R\x91P_\x90`\x01`\x01`\xA0\x1B\x03\x89\x16\x90c\x04\xECcQ\x90`d\x01` `@Q\x80\x83\x03\x81\x86Z\xFA\x15\x80\x15a\x0F\x1EW=__>=_\xFD[PPPP`@Q=`\x1F\x19`\x1F\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0FB\x91\x90a\x17\xDCV[`\x01`\x01`\xC0\x1B\x03\x16\x90P_a\x0FW\x82a\x0FuV[\x90P\x81a\x0Fe\x8A\x83\x8Aa\0\xD8V[\x95P\x95PPPPP\x93P\x93\x91PPV[``__a\x0F\x82\x84a\x10>V[a\xFF\xFF\x16`\x01`\x01`@\x1B\x03\x81\x11\x15a\x0F\x9DWa\x0F\x9Da\x10\x85V[`@Q\x90\x80\x82R\x80`\x1F\x01`\x1F\x19\x16` \x01\x82\x01`@R\x80\x15a\x0F\xC7W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P_\x80[\x82Q\x82\x10\x80\x15a\x0F\xDEWPa\x01\0\x81\x10[\x15a\x104W`\x01\x81\x1B\x93P\x85\x84\x16\x15a\x10$W\x80`\xF8\x1B\x83\x83\x81Q\x81\x10a\x10\x07Wa\x10\x07a\x15\xEEV[` \x01\x01\x90`\x01`\x01`\xF8\x1B\x03\x19\x16\x90\x81_\x1A\x90SP\x81`\x01\x01\x91P[a\x10-\x81a\x181V[\x90Pa\x0F\xCDV[P\x90\x94\x93PPPPV[_\x80[\x82\x15a\x10hWa\x10R`\x01\x84a\x18\xD7V[\x90\x92\x16\x91\x80a\x10`\x81a\x18\xEAV[\x91PPa\x10AV[\x92\x91PPV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x81\x14a\x10\x82W__\xFD[PV[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`@Q`\x1F\x82\x01`\x1F\x19\x16\x81\x01`\x01`\x01`@\x1B\x03\x81\x11\x82\x82\x10\x17\x15a\x10\xC1Wa\x10\xC1a\x10\x85V[`@R\x91\x90PV[c\xFF\xFF\xFF\xFF\x81\x16\x81\x14a\x10\x82W__\xFD[\x805a\x10\xE5\x81a\x10\xC9V[\x91\x90PV[___``\x84\x86\x03\x12\x15a\x10\xFCW__\xFD[\x835a\x11\x07\x81a\x10nV[\x92P` \x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\x11!W__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x111W__\xFD[\x805`\x01`\x01`@\x1B\x03\x81\x11\x15a\x11JWa\x11Ja\x10\x85V[a\x11]`\x1F\x82\x01`\x1F\x19\x16` \x01a\x10\x99V[\x81\x81R\x87` \x83\x85\x01\x01\x11\x15a\x11qW__\xFD[\x81` \x84\x01` \x83\x017_` \x83\x83\x01\x01R\x80\x94PPPPa\x11\x95`@\x85\x01a\x10\xDAV[\x90P\x92P\x92P\x92V[_\x82\x82Q\x80\x85R` \x85\x01\x94P` \x81`\x05\x1B\x83\x01\x01` \x85\x01_[\x83\x81\x10\x15a\x12?W\x84\x83\x03`\x1F\x19\x01\x88R\x81Q\x80Q\x80\x85R` \x91\x82\x01\x91\x85\x01\x90_[\x81\x81\x10\x15a\x12&W\x83Q\x80Q`\x01`\x01`\xA0\x1B\x03\x16\x84R` \x80\x82\x01Q\x81\x86\x01R`@\x91\x82\x01Q`\x01`\x01``\x1B\x03\x16\x91\x85\x01\x91\x90\x91R\x90\x93\x01\x92``\x90\x92\x01\x91`\x01\x01a\x11\xDDV[PP` \x99\x8A\x01\x99\x90\x94P\x92\x90\x92\x01\x91P`\x01\x01a\x11\xBAV[P\x90\x96\x95PPPPPPV[` \x81R_a\x12]` \x83\x01\x84a\x11\x9EV[\x93\x92PPPV[__\x83`\x1F\x84\x01\x12a\x12tW__\xFD[P\x815`\x01`\x01`@\x1B\x03\x81\x11\x15a\x12\x8AW__\xFD[` \x83\x01\x91P\x83` \x82`\x05\x1B\x85\x01\x01\x11\x15a\x12\xA4W__\xFD[\x92P\x92\x90PV[______`\x80\x87\x89\x03\x12\x15a\x12\xC0W__\xFD[\x865a\x12\xCB\x81a\x10nV[\x95P` \x87\x015a\x12\xDB\x81a\x10\xC9V[\x94P`@\x87\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\x12\xF5W__\xFD[\x87\x01`\x1F\x81\x01\x89\x13a\x13\x05W__\xFD[\x805`\x01`\x01`@\x1B\x03\x81\x11\x15a\x13\x1AW__\xFD[\x89` \x82\x84\x01\x01\x11\x15a\x13+W__\xFD[` \x91\x90\x91\x01\x94P\x92P``\x87\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\x13MW__\xFD[a\x13Y\x89\x82\x8A\x01a\x12dV[\x97\x9A\x96\x99P\x94\x97P\x92\x95\x93\x94\x92PPPV[_\x81Q\x80\x84R` \x84\x01\x93P` \x83\x01_[\x82\x81\x10\x15a\x13\xA1W\x81Qc\xFF\xFF\xFF\xFF\x16\x86R` \x95\x86\x01\x95\x90\x91\x01\x90`\x01\x01a\x13}V[P\x93\x94\x93PPPPV[` \x81R_\x82Q`\x80` \x84\x01Ra\x13\xC6`\xA0\x84\x01\x82a\x13kV[\x90P` \x84\x01Q`\x1F\x19\x84\x83\x03\x01`@\x85\x01Ra\x13\xE3\x82\x82a\x13kV[\x91PP`@\x84\x01Q`\x1F\x19\x84\x83\x03\x01``\x85\x01Ra\x14\x01\x82\x82a\x13kV[``\x86\x01Q\x85\x82\x03`\x1F\x19\x01`\x80\x87\x01R\x80Q\x80\x83R\x91\x93P` \x90\x81\x01\x92P\x80\x84\x01\x91\x90`\x05\x82\x90\x1B\x85\x01\x01_[\x82\x81\x10\x15a\x054W`\x1F\x19\x86\x83\x03\x01\x84Ra\x14L\x82\x86Qa\x13kV[` \x95\x86\x01\x95\x94\x90\x94\x01\x93\x91P`\x01\x01a\x140V[_`\x01`\x01`@\x1B\x03\x82\x11\x15a\x14yWa\x14ya\x10\x85V[P`\x05\x1B` \x01\x90V[___``\x84\x86\x03\x12\x15a\x14\x95W__\xFD[\x835a\x14\xA0\x81a\x10nV[\x92P` \x84\x015`\x01`\x01`@\x1B\x03\x81\x11\x15a\x14\xBAW__\xFD[\x84\x01`\x1F\x81\x01\x86\x13a\x14\xCAW__\xFD[\x805a\x14\xDDa\x14\xD8\x82a\x14aV[a\x10\x99V[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x88\x83\x11\x15a\x14\xFEW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a\x15 W\x835\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a\x15\x05V[\x94Pa\x11\x95\x92PPP`@\x85\x01a\x10\xDAV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R_\x91\x84\x01\x90`@\x84\x01\x90\x83[\x81\x81\x10\x15a\x15iW\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x15KV[P\x90\x95\x94PPPPPV[___``\x84\x86\x03\x12\x15a\x15\x86W__\xFD[\x835a\x15\x91\x81a\x10nV[\x92P` \x84\x015\x91P`@\x84\x015a\x15\xA8\x81a\x10\xC9V[\x80\x91PP\x92P\x92P\x92V[\x82\x81R`@` \x82\x01R_a\x15\xCB`@\x83\x01\x84a\x11\x9EV[\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x15\xE3W__\xFD[\x81Qa\x12]\x81a\x10nV[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[_` \x82\x84\x03\x12\x15a\x16\x12W__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x16'W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x167W__\xFD[\x80Qa\x16Ea\x14\xD8\x82a\x14aV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x86\x83\x11\x15a\x16fW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a\x16\x88W\x83Q\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a\x16mV[\x96\x95PPPPPPV[_` \x82\x84\x03\x12\x15a\x16\xA2W__\xFD[\x81Q`\x01`\x01``\x1B\x03\x81\x16\x81\x14a\x12]W__\xFD[c\xFF\xFF\xFF\xFF\x84\x16\x81R`@` \x82\x01\x81\x90R\x81\x01\x82\x90R_`\x01`\x01`\xFB\x1B\x03\x83\x11\x15a\x16\xE3W__\xFD[\x82`\x05\x1B\x80\x85``\x85\x017\x91\x90\x91\x01``\x01\x94\x93PPPPV[_` \x82\x84\x03\x12\x15a\x17\rW__\xFD[\x81Q`\x01`\x01`@\x1B\x03\x81\x11\x15a\x17\"W__\xFD[\x82\x01`\x1F\x81\x01\x84\x13a\x172W__\xFD[\x80Qa\x17@a\x14\xD8\x82a\x14aV[\x80\x82\x82R` \x82\x01\x91P` \x83`\x05\x1B\x85\x01\x01\x92P\x86\x83\x11\x15a\x17aW__\xFD[` \x84\x01\x93P[\x82\x84\x10\x15a\x16\x88W\x83Qa\x17{\x81a\x10\xC9V[\x82R` \x93\x84\x01\x93\x90\x91\x01\x90a\x17hV[\x81\x83R\x81\x81` \x85\x017P_\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1F\x90\x91\x01`\x1F\x19\x16\x90\x91\x01\x01\x90V[c\xFF\xFF\xFF\xFF\x84\x16\x81R`@` \x82\x01R_a\x17\xD3`@\x83\x01\x84\x86a\x17\x8CV[\x95\x94PPPPPV[_` \x82\x84\x03\x12\x15a\x17\xECW__\xFD[\x81Q`\x01`\x01`\xC0\x1B\x03\x81\x16\x81\x14a\x12]W__\xFD[_` \x82\x84\x03\x12\x15a\x18\x12W__\xFD[\x81Qa\x12]\x81a\x10\xC9V[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[_`\x01\x82\x01a\x18BWa\x18Ba\x18\x1DV[P`\x01\x01\x90V[_`\xFF\x82\x16`\xFF\x81\x03a\x18^Wa\x18^a\x18\x1DV[`\x01\x01\x92\x91PPV[`@\x81R_a\x18z`@\x83\x01\x85\x87a\x17\x8CV[\x90Pc\xFF\xFF\xFF\xFF\x83\x16` \x83\x01R\x94\x93PPPPV[_`@\x82\x01c\xFF\xFF\xFF\xFF\x85\x16\x83R`@` \x84\x01R\x80\x84Q\x80\x83R``\x85\x01\x91P` \x86\x01\x92P_[\x81\x81\x10\x15a\x12?W\x83Q\x83R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x18\xB9V[\x81\x81\x03\x81\x81\x11\x15a\x10hWa\x10ha\x18\x1DV[_a\xFF\xFF\x82\x16a\xFF\xFF\x81\x03a\x18^Wa\x18^a\x18\x1DV\xFE\xA2dipfsX\"\x12 \x98:u\x07\xFF\xB0=h\xFF^BB44\xB1\x07\xB2\xA2Q*\x8E\x99\x89\x03r\x06\xF7\x87\x12\xFC\xD7\xEDdsolcC\0\x08\x1B\x003",
    );
    /**```solidity
struct CheckSignaturesIndices { uint32[] nonSignerQuorumBitmapIndices; uint32[] quorumApkIndices; uint32[] totalStakeIndices; uint32[][] nonSignerStakeIndices; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CheckSignaturesIndices {
        pub nonSignerQuorumBitmapIndices: alloy::sol_types::private::Vec<u32>,
        pub quorumApkIndices: alloy::sol_types::private::Vec<u32>,
        pub totalStakeIndices: alloy::sol_types::private::Vec<u32>,
        pub nonSignerStakeIndices: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Vec<u32>,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<32>>,
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<32>>,
            alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<32>>,
            alloy::sol_types::sol_data::Array<
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<32>>,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Vec<u32>,
            alloy::sol_types::private::Vec<u32>,
            alloy::sol_types::private::Vec<u32>,
            alloy::sol_types::private::Vec<alloy::sol_types::private::Vec<u32>>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckSignaturesIndices> for UnderlyingRustTuple<'_> {
            fn from(value: CheckSignaturesIndices) -> Self {
                (
                    value.nonSignerQuorumBitmapIndices,
                    value.quorumApkIndices,
                    value.totalStakeIndices,
                    value.nonSignerStakeIndices,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CheckSignaturesIndices {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    nonSignerQuorumBitmapIndices: tuple.0,
                    quorumApkIndices: tuple.1,
                    totalStakeIndices: tuple.2,
                    nonSignerStakeIndices: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for CheckSignaturesIndices {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for CheckSignaturesIndices {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.nonSignerQuorumBitmapIndices,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.quorumApkIndices),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalStakeIndices),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Array<
                            alloy::sol_types::sol_data::Uint<32>,
                        >,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonSignerStakeIndices),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for CheckSignaturesIndices {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for CheckSignaturesIndices {
            const NAME: &'static str = "CheckSignaturesIndices";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "CheckSignaturesIndices(uint32[] nonSignerQuorumBitmapIndices,uint32[] quorumApkIndices,uint32[] totalStakeIndices,uint32[][] nonSignerStakeIndices)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.nonSignerQuorumBitmapIndices,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.quorumApkIndices,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.totalStakeIndices,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Array<
                            alloy::sol_types::sol_data::Uint<32>,
                        >,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.nonSignerStakeIndices,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for CheckSignaturesIndices {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.nonSignerQuorumBitmapIndices,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.quorumApkIndices,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalStakeIndices,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Array<
                            alloy::sol_types::sol_data::Uint<32>,
                        >,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.nonSignerStakeIndices,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Uint<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonSignerQuorumBitmapIndices,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Uint<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.quorumApkIndices,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Uint<32>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalStakeIndices,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<32>,
                    >,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonSignerStakeIndices,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Operator { address operator; bytes32 operatorId; uint96 stake; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Operator {
        pub operator: alloy::sol_types::private::Address,
        pub operatorId: alloy::sol_types::private::FixedBytes<32>,
        pub stake: alloy::sol_types::private::primitives::aliases::U96,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<96>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
            alloy::sol_types::private::primitives::aliases::U96,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Operator> for UnderlyingRustTuple<'_> {
            fn from(value: Operator) -> Self {
                (value.operator, value.operatorId, value.stake)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Operator {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    operatorId: tuple.1,
                    stake: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Operator {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Operator {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorId),
                    <alloy::sol_types::sol_data::Uint<
                        96,
                    > as alloy_sol_types::SolType>::tokenize(&self.stake),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Operator {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Operator {
            const NAME: &'static str = "Operator";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Operator(address operator,bytes32 operatorId,uint96 stake)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.operator,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.operatorId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        96,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.stake)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Operator {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operator,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operatorId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        96,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.stake)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operator,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operatorId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    96,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.stake,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**Function with signature `getCheckSignaturesIndices(address,uint32,bytes,bytes32[])` and selector `0x4f739f74`.
```solidity
function getCheckSignaturesIndices(address registryCoordinator, uint32 referenceBlockNumber, bytes memory quorumNumbers, bytes32[] memory nonSignerOperatorIds) external view returns (CheckSignaturesIndices memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCheckSignaturesIndicesCall {
        pub registryCoordinator: alloy::sol_types::private::Address,
        pub referenceBlockNumber: u32,
        pub quorumNumbers: alloy::sol_types::private::Bytes,
        pub nonSignerOperatorIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
    }
    ///Container type for the return parameters of the [`getCheckSignaturesIndices(address,uint32,bytes,bytes32[])`](getCheckSignaturesIndicesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getCheckSignaturesIndicesReturn {
        pub _0: <CheckSignaturesIndices as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                u32,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<alloy::sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCheckSignaturesIndicesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCheckSignaturesIndicesCall) -> Self {
                    (
                        value.registryCoordinator,
                        value.referenceBlockNumber,
                        value.quorumNumbers,
                        value.nonSignerOperatorIds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCheckSignaturesIndicesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registryCoordinator: tuple.0,
                        referenceBlockNumber: tuple.1,
                        quorumNumbers: tuple.2,
                        nonSignerOperatorIds: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (CheckSignaturesIndices,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <CheckSignaturesIndices as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCheckSignaturesIndicesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getCheckSignaturesIndicesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getCheckSignaturesIndicesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCheckSignaturesIndicesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<32>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCheckSignaturesIndicesReturn;
            type ReturnTuple<'a> = (CheckSignaturesIndices,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCheckSignaturesIndices(address,uint32,bytes,bytes32[])";
            const SELECTOR: [u8; 4] = [79u8, 115u8, 159u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.registryCoordinator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.referenceBlockNumber),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.nonSignerOperatorIds),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getOperatorState(address,bytes,uint32)` and selector `0x3563b0d1`.
```solidity
function getOperatorState(address registryCoordinator, bytes memory quorumNumbers, uint32 blockNumber) external view returns (Operator[][] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorState_0Call {
        pub registryCoordinator: alloy::sol_types::private::Address,
        pub quorumNumbers: alloy::sol_types::private::Bytes,
        pub blockNumber: u32,
    }
    ///Container type for the return parameters of the [`getOperatorState(address,bytes,uint32)`](getOperatorState_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorState_0Return {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Vec<
                <Operator as alloy::sol_types::SolType>::RustType,
            >,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorState_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorState_0Call) -> Self {
                    (value.registryCoordinator, value.quorumNumbers, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorState_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registryCoordinator: tuple.0,
                        quorumNumbers: tuple.1,
                        blockNumber: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Array<Operator>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::Vec<
                        <Operator as alloy::sol_types::SolType>::RustType,
                    >,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorState_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorState_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorState_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorState_0Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorState_0Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Array<Operator>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorState(address,bytes,uint32)";
            const SELECTOR: [u8; 4] = [53u8, 99u8, 176u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.registryCoordinator,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getOperatorState(address,bytes32,uint32)` and selector `0xcefdc1d4`.
```solidity
function getOperatorState(address registryCoordinator, bytes32 operatorId, uint32 blockNumber) external view returns (uint256, Operator[][] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorState_1Call {
        pub registryCoordinator: alloy::sol_types::private::Address,
        pub operatorId: alloy::sol_types::private::FixedBytes<32>,
        pub blockNumber: u32,
    }
    ///Container type for the return parameters of the [`getOperatorState(address,bytes32,uint32)`](getOperatorState_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorState_1Return {
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
        pub _1: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Vec<
                <Operator as alloy::sol_types::SolType>::RustType,
            >,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::FixedBytes<32>,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorState_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorState_1Call) -> Self {
                    (value.registryCoordinator, value.operatorId, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorState_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registryCoordinator: tuple.0,
                        operatorId: tuple.1,
                        blockNumber: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Array<Operator>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::Vec<
                        <Operator as alloy::sol_types::SolType>::RustType,
                    >,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorState_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorState_1Return) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorState_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0, _1: tuple.1 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorState_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorState_1Return;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::Array<Operator>,
                >,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorState(address,bytes32,uint32)";
            const SELECTOR: [u8; 4] = [206u8, 253u8, 193u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.registryCoordinator,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorId),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getQuorumBitmapsAtBlockNumber(address,bytes32[],uint32)` and selector `0x5c155662`.
```solidity
function getQuorumBitmapsAtBlockNumber(address registryCoordinator, bytes32[] memory operatorIds, uint32 blockNumber) external view returns (uint256[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getQuorumBitmapsAtBlockNumberCall {
        pub registryCoordinator: alloy::sol_types::private::Address,
        pub operatorIds: alloy::sol_types::private::Vec<
            alloy::sol_types::private::FixedBytes<32>,
        >,
        pub blockNumber: u32,
    }
    ///Container type for the return parameters of the [`getQuorumBitmapsAtBlockNumber(address,bytes32[],uint32)`](getQuorumBitmapsAtBlockNumberCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getQuorumBitmapsAtBlockNumberReturn {
        pub _0: alloy::sol_types::private::Vec<
            alloy::sol_types::private::primitives::aliases::U256,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::FixedBytes<32>,
                >,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapsAtBlockNumberCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapsAtBlockNumberCall) -> Self {
                    (value.registryCoordinator, value.operatorIds, value.blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getQuorumBitmapsAtBlockNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registryCoordinator: tuple.0,
                        operatorIds: tuple.1,
                        blockNumber: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<
                    alloy::sol_types::private::primitives::aliases::U256,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapsAtBlockNumberReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapsAtBlockNumberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getQuorumBitmapsAtBlockNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getQuorumBitmapsAtBlockNumberCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Array<
                    alloy::sol_types::sol_data::FixedBytes<32>,
                >,
                alloy::sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getQuorumBitmapsAtBlockNumberReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<256>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getQuorumBitmapsAtBlockNumber(address,bytes32[],uint32)";
            const SELECTOR: [u8; 4] = [92u8, 21u8, 86u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.registryCoordinator,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::FixedBytes<32>,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorIds),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.blockNumber),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`OperatorStateRetriever`](self) function calls.
    pub enum OperatorStateRetrieverCalls {
        getCheckSignaturesIndices(getCheckSignaturesIndicesCall),
        getOperatorState_0(getOperatorState_0Call),
        getOperatorState_1(getOperatorState_1Call),
        getQuorumBitmapsAtBlockNumber(getQuorumBitmapsAtBlockNumberCall),
    }
    #[automatically_derived]
    impl OperatorStateRetrieverCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [53u8, 99u8, 176u8, 209u8],
            [79u8, 115u8, 159u8, 116u8],
            [92u8, 21u8, 86u8, 98u8],
            [206u8, 253u8, 193u8, 212u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for OperatorStateRetrieverCalls {
        const NAME: &'static str = "OperatorStateRetrieverCalls";
        const MIN_DATA_LENGTH: usize = 96usize;
        const COUNT: usize = 4usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::getCheckSignaturesIndices(_) => {
                    <getCheckSignaturesIndicesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorState_0(_) => {
                    <getOperatorState_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorState_1(_) => {
                    <getOperatorState_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getQuorumBitmapsAtBlockNumber(_) => {
                    <getQuorumBitmapsAtBlockNumberCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<OperatorStateRetrieverCalls>] = &[
                {
                    fn getOperatorState_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OperatorStateRetrieverCalls> {
                        <getOperatorState_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OperatorStateRetrieverCalls::getOperatorState_0)
                    }
                    getOperatorState_0
                },
                {
                    fn getCheckSignaturesIndices(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OperatorStateRetrieverCalls> {
                        <getCheckSignaturesIndicesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OperatorStateRetrieverCalls::getCheckSignaturesIndices)
                    }
                    getCheckSignaturesIndices
                },
                {
                    fn getQuorumBitmapsAtBlockNumber(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OperatorStateRetrieverCalls> {
                        <getQuorumBitmapsAtBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(
                                OperatorStateRetrieverCalls::getQuorumBitmapsAtBlockNumber,
                            )
                    }
                    getQuorumBitmapsAtBlockNumber
                },
                {
                    fn getOperatorState_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<OperatorStateRetrieverCalls> {
                        <getOperatorState_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(OperatorStateRetrieverCalls::getOperatorState_1)
                    }
                    getOperatorState_1
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::getCheckSignaturesIndices(inner) => {
                    <getCheckSignaturesIndicesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorState_0(inner) => {
                    <getOperatorState_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getOperatorState_1(inner) => {
                    <getOperatorState_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getQuorumBitmapsAtBlockNumber(inner) => {
                    <getQuorumBitmapsAtBlockNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::getCheckSignaturesIndices(inner) => {
                    <getCheckSignaturesIndicesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorState_0(inner) => {
                    <getOperatorState_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorState_1(inner) => {
                    <getOperatorState_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getQuorumBitmapsAtBlockNumber(inner) => {
                    <getQuorumBitmapsAtBlockNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`OperatorStateRetriever`](self) contract instance.

See the [wrapper's documentation](`OperatorStateRetrieverInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> OperatorStateRetrieverInstance<T, P, N> {
        OperatorStateRetrieverInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<OperatorStateRetrieverInstance<T, P, N>>,
    > {
        OperatorStateRetrieverInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        OperatorStateRetrieverInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`OperatorStateRetriever`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`OperatorStateRetriever`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct OperatorStateRetrieverInstance<
        T,
        P,
        N = alloy_contract::private::Ethereum,
    > {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for OperatorStateRetrieverInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("OperatorStateRetrieverInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > OperatorStateRetrieverInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`OperatorStateRetriever`](self) contract instance.

See the [wrapper's documentation](`OperatorStateRetrieverInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<OperatorStateRetrieverInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> OperatorStateRetrieverInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> OperatorStateRetrieverInstance<T, P, N> {
            OperatorStateRetrieverInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > OperatorStateRetrieverInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`getCheckSignaturesIndices`] function.
        pub fn getCheckSignaturesIndices(
            &self,
            registryCoordinator: alloy::sol_types::private::Address,
            referenceBlockNumber: u32,
            quorumNumbers: alloy::sol_types::private::Bytes,
            nonSignerOperatorIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCheckSignaturesIndicesCall, N> {
            self.call_builder(
                &getCheckSignaturesIndicesCall {
                    registryCoordinator,
                    referenceBlockNumber,
                    quorumNumbers,
                    nonSignerOperatorIds,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorState_0`] function.
        pub fn getOperatorState_0(
            &self,
            registryCoordinator: alloy::sol_types::private::Address,
            quorumNumbers: alloy::sol_types::private::Bytes,
            blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorState_0Call, N> {
            self.call_builder(
                &getOperatorState_0Call {
                    registryCoordinator,
                    quorumNumbers,
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorState_1`] function.
        pub fn getOperatorState_1(
            &self,
            registryCoordinator: alloy::sol_types::private::Address,
            operatorId: alloy::sol_types::private::FixedBytes<32>,
            blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorState_1Call, N> {
            self.call_builder(
                &getOperatorState_1Call {
                    registryCoordinator,
                    operatorId,
                    blockNumber,
                },
            )
        }
        ///Creates a new call builder for the [`getQuorumBitmapsAtBlockNumber`] function.
        pub fn getQuorumBitmapsAtBlockNumber(
            &self,
            registryCoordinator: alloy::sol_types::private::Address,
            operatorIds: alloy::sol_types::private::Vec<
                alloy::sol_types::private::FixedBytes<32>,
            >,
            blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            getQuorumBitmapsAtBlockNumberCall,
            N,
        > {
            self.call_builder(
                &getQuorumBitmapsAtBlockNumberCall {
                    registryCoordinator,
                    operatorIds,
                    blockNumber,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > OperatorStateRetrieverInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
